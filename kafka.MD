# Kafka Cluster: 대규모 데이터 처리를 위한 핵심 가이드
- Kafka는 대규모의 데이터를 실시간으로 처리하기 위한 분신 이벤트 스트리밍 플랫폼이다.
링크드인에서 개발되어 현재는 아파치 소프트웨어 재단에서 오픈 소스로 관리되고 있으며, 높은 처리량과 확장성을 바탕으로 현대 데이터 아키텍처의 핵심 요소로 자리 잡았다.

## 기본 구조 및 동작 원리
### 카프카는 **프로듀서(Producer)**, **브로커(Broker)**, **컨슈머(Consumer)** 세 가지 주요 구성 요소로 이루어져 있다.
- **프로듀서(Producer)**: 이벤트(데이터)를 생성하여 브로커에게 전송하는 역할
- **브로커(Broker)**: 브로커에 저장된 이벤트를 가져와(pull) 처리
- **컨슈머(Consumer)**: 프로듀서로부터 받은 이벤트를 안전하게 저장하고, 컨슈머가 이벤트를 가져갈 수 있도록 중개하는 역할을 하는 카프카 서버를 의미

리러한 구성 요소들은 `토픽(Topic)`과 `파티션(Partition)`이라는 개념을 통해 유기적으로 동작

- **토픽(Topic)**: 이벤트를 논리적으로 구분하는 단위. 예를 들어 '클릭 로그', '주문 정보' 등 데이터의 종류별로 토픽을 생성하여 관리할 수 있다.
- **파티션(Partition)**: 하나의 토픽을 여러 개로 나눈 물리적인 저장소. 각 파티션은 독립적으로 관리되며, 이를 통해 데이터의 병렬 처리가 가능해져 높을 처리량을 확보할 수 있다.

여러 대의 브로커가 모여 **클러스터(Cluster)** 구성하며, 토픽의 파티션들은 이 클러스터 내의 여러 브로커에 분산 저장된다.
이러한 분산 구조는 특정 브로커에 장애가 발생하더라도 다른 브로커를 통해 서비스를 지속할 수 있는 고가용성을 제공한다.

## 내구성 및 장애 대응
카프카는 데이터 손실을 방지하고 장애 상황에서도 안정적인 서비스를 제공하기 위해 다음과 같은 기능을 지원한다.

- **리플리케이션(Replication)**: 각 파티션의 데이터를 여러 브로커에 복제하여 저장하는 기능.이 복제본 중 하나를 `리더(Leader)`가 되고 나머지는 `팔로워(Follwer)`가 된다. 
모든 읽기 및 쓰기 작업은 리터를 통해 이루어지며, 팔로워는 리더의 데이터를 복제한다. 리더에 장애가 발생하면 팔로워 중 하나가 새로운 리더로 선출되어 서비스 중단을 최소화 한다.
- **acks 설정**: 프로듀서가 보낸 데이터가 얼마나 안정적으로 저장되었는지 확인하는 옵션이다.
  - `acks=0`: 프로듀서는 브로커로부터 응답을 기다리지 않고 다음 데이터를 전송하여 속도가 빠르지만 데이터 유실 가능성이 있다.
  - `acks=1`: 리더 브로커에 데이터가 저장되면 응답을 받는다. 리더 장애 시 데이터가 유실될 수 있다.
  - `acks=all`: 리더와 모든 팔로워 브로커에 데이터가 복제되면 응답을 받는다. 가장 높은 데이터 내구성을 보장하지만 속도는 가장 느리다.
- **min.insync.replicas**: `acks=all`로 설정하였을 때, 최소 몇 개의 리플리카에 데이터가 저장되어야 프로듀서에게 성공적으로 응답할지를 결정하는 브로커 옵션이다.
예를 들어, replication.factor가 3이고 min.insync.replicas가 2로 설정된 경우, 리더를 포함하여 최소 2개의 리클리카에 데이터가 저장되어야 쓰기 작업이 성공한 것으로 간주된다.
이는 브로커 하나에 장애가 발생하더라도 데이터 무손실을 보장하면서 가용성을 유지할 수 있도록 하는 권장 설정이다.

## 데이터 관리 및 처리
- **오프셋(Offset)**: 각 파티션 내에서 메시지의 위치를 나타내는 고유한 번호이다. 컨슈머는 이 오프셋을 기준으로 데이터를 어디까지 읽었는지 추척한다.
- **컨슈머 그롭(Consumer Group)**: 하나 이상의 컨슈머를 묶는 논리적이 단위이다. 하나의 토픽에 여러 컨슈머 그룹이 접근할 수 있으며, 각 그룹은 독립적으로 오프셋을 관리한다.
이를 통해 동일한 데이터를 여러 다른 목적으로 병렬 처리할 수 있다. 한 컨슈머 그룹 내의 컨슈머들은 토픽의 각기 다른 파티션에 할당되어 작업을 분산 처리함으로써 처리량을 높일 수 있다.

## 최신 기술 발전: KRaft 모드
과거 카프카는 클러스터의 메타데이터(브로커 정보, 토픽 설정 등)을 관리를 위해 `주키퍼(Zookeeper)`라는 별도의 분산 코디네이션 시스템에 의존했다.
하지만 카프카 2.8 버전부터 `KRaft(Kafka Raft Metadata mode)` 모드가 도입되어 주키퍼 없이도 카프카 자체적으로 메타데이터 관리가 가능해졌다.
Kafka 모드는 아키텍처를 단순화하고, 관리 부담을 줄이며, 확장성과 장애 복구 속도를 향상키시는 장점을 제공한다.

## 주요 활용 사례
- **실시간 데이터 파이프라인**: 서로 다른 시스템 간에 데이터를 실시간으로 전달하는 데 사용된다.
- **로그 및 메트릭 수집**: 대규모 시스템에서 발생하는 로그와 메트릭 데이터를 중앙에서 실시간으로 수집하고 분석하는 데 효과적이다.
- **이벤트 기반 아키텍처**: 서비스 간의 결합도를 낮추고 비동기적인 데이터 처리를 구현하기 위해 이벤트 브로커로 활용된다.
- **실시간 스트리밍 분석**: 금융 거래 데이터, IoT 센서 데이터 등 실시간으로 발생하는 대용량 스트림 데이터를 처리하고 분석하는 데 사용된다.