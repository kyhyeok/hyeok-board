# Transactional Messaging: 분산 시스템의 데이터 일관성 보장
- 마이크로서비스 아키텍처에서 데이터 일관성과 원자성을 보장하는 것은 핵심적인 과제이다.
특히 게시글/댓글/좋아요/조회수 서비스(Producer)에서 발생한 이벤트가 인기글 서비스(Consumer)로 Kafka를 통해 안정적으로 전달되어야 하는 시나리오에서 그 중요성이 부각된다.
이러한 이벤트 기반 통신 구조를 `Event Driven Architecture (EDA)`라고 하며, Kafka와 같은 메시지 브로커는 시스템 간의 결합도를 낮추고 대규모 데이터를 안전하고 효율적으로 처리하는 데 필수이다.

## 문제 상황: 분산된 시스템에서의 데이터 불일치
- 프로젝트에서 관계형 데이터베이스의 트랜잭션을 사용하여 게시글 데이터와 관련 수치 데이터를 하나의 트랜잭션으로 관리하는 등, `데이터의 원자성(Atomicity)`과 `일관성(Consistency)`을 보장해왔다.
즉, "모두 실행되거나 모두 실행되지 않거나"의 원칙을 지켜왔다.
하지만 서비스 간의 비동기 통신을 위해 Kafka를 도입하면서 새로운 문제가 발생했다. 게시글 서비스에서 게시글 생성과 같은 비즈니스 로직 수행(데이터베이스 쓰기)과 Kafka로 이벤트 전송을 독립적인 작업이다.
 
### Producer의 장애 전파 방지 필요성
- Producer는 비즈니스 로직을 수행하고   (게시글 생성 후 DB 저장), 그 결과를 이벤트로 Kafka에 전송한다. 이 과정에서 네트워크 순단, Kafka Broker 장애 등 다양한 문제가 발생할 수 있다.
### 데이터 유실 및 불일치 위험
- 만약 데이터베이스에는 게시글을 성공적으로 저장되었으나, Kafka로의 이벤트 전송에 실패한다면? Producer는 게시글이 생성된 것을 알지만, Consumer인 인기글 서비스는 이 사실을 전달받지 못하게 되어 `데이터 불일치(Inconsistency)`가 발생한다.
이는 "신뢰할 수 있는 시스템인 Kafka로 아직 데이터가 전송되지 못했기 때문에, Producer가 생상 및 전파해야 하는 이벤트 데이터는 유실될 수 밖에 없는 상황"으로 이어진다

## 해결 과제: 비즈니스 로직과 이벤트 전송의 원자성 보장
- 이러한 문제를 해결하기 위해서는 `비즈니스 로직 수행(DB 저장)과 이벤트 전송(Kafka 발행)을 하나의 원자적인 트랜잭션으로 처리`해야 한다.
즉, 두 작업이 모두 성공하거나 모두 실패하도록 보장해야 한다.
- 단순히 `publishEvent()` 코드를 기존 스프링의 `@Transactional` 범위 내에 포함시키는 것은 충분하지 않으며, 그 이유는 다음과 같다.

### 이질적인 시스템
- 우리가 사용하던 트랜잭션은 MySQL과 같은 `단일 관계형 데이터베이스에 대한 트랜잭션`이다. MySQL의 상태 변경과 Kafka로의 데이터 전송은 서로 다른 시스템에 대한 작업이다.
MySQL의 트랜잭션 기능만으로는 이 둘을 하나의 트랜잭션으로 묶을 수 없다.
### 성능 및 장애 전파
- 만약 트랜잭션 내에서 Kafka 전송 작업이 장애로 인해 블로킹된다면, 해당 DB 트랜잭선이 오랫동안 점유되어 서버 애플리케이션과 MySQL에까지 장애가 전파될 수 있다.
또한, DB 커밋이 실패했는데 이벤트 전송은 이미 완료되었거나, 그 반대의 상황도 발생할 수 있다.

## 해결 방안: Transactional Messaging (분산 트랜잭션)
- 이처럼 서로 다른 시스템(데이터베이스와 메시지 브로커)간의 데이터 일관성을 보장하며 메시지를 안정적으로 전달하기 위한 방법을 `Transactional Messaging`이라고 한다.
이는 `분산 트랜잭션(Distributed Transaction)`의 한 형태로, 비즈니스 로직 처리와 메시지 전송을 원자적으로 묶어 데이터 유실 없는 안정적인 메시지 전달을 목표로 한다.
- 이러한 보장은 반드시 실시간일 필요는 없으며, 비즈니스 로직이 우선 처리된 후 이벤트 전송은 장애가 해손된 뒤 늦게 처리되어도 최종적으로 일관성이 유지되는 `최종 일관성(Eveenually Consistency)`모델을 따를 수 있다.

## Transactional Messaging을 달성하기 위한 몇 가지 주요 패턴

### Two Phase Commit (2PC, 2단계 커밋)
- 개념
    분산된 시스템들이 하나의 트랜잭션에 참여할 때, `조정자(Coordinator)`가 모든 `참여자(시스템)`에게 커밋할 준비가 되었는지 묻고`(1단계: Prepare)`, 모두 '예'라고 답하면 최종적으로 커밋을 지시하는`(2단계: Commit)`방식이다. 하나라도 실패하면 모두 롤백된다.
- 동작 방식 
  - 준비 단계 (Prepare Phase): 조정자가 모든 참여자에게 "트랜잭션을 커밋할 준비가 되었는가?"라고 요청한다. 참여자들은 작업을 처리하고 준비가 되면 '예'를 응답한다.
  - 커밋 단계 (Commit Phase): 모든 참여자로부터 '예' 응답을 받으면, 조정자는 모든 참여자에게 "트랜잭션을 커밋하라"로 명령한다. 만약 하나라도 '아니요'를 응답하거나 타임아웃이 발생하면, 모두에게 '롤백하라'고 명령한다
- 장점
  - 분산된 시스템 간의 트랜잭션 원자성을 강력하게 보장한다
- 단점
  - 블로킹 및 성능 저하: 모든 참여자의 응답을 기다려야 하므로 전체 프로세스가 느려지고, 트랜잭션 동안 리소스가 잠겨(Blocking) 성능이 저하될 수 있다
  - 코디네이터 의존성: 조정자에게 장애가 발생하면 모든 참여자가 다음 단계를 알 수 없어 대기 상태에 빠질 수 있다(SPOF: 단일 장애점)
  - 구현 복잡성: Kafka와 MySQL 같은 시스템들은 기본적으로 2PC를 지원하지 않아 통합이 매우 복잡하고 현실적으로 적용하기 어렵다
- 결론
  - 개념적으로 완벽한 원자성을 보장하지만, 성능 문제와 복잡성 때문에 현대 마이크로서비스 환경, 특히 Kafka를 사용하는 시스템에는 적합하지 않다.

### Transactional Outbox (트랜잭셔널 아웃박스)
- 개념
  - `비즈니스 로직 처리(데이터 저장)`와 발행할 이벤트를 동일한 데이터베이스 트랜잭션 내에서 처리하는패턴이다. 즉, 실제 이벤트를 외부로 바로 보내는 대신, 이벤트 내용을 데이터베이스 안의 `Outbox` 테이블에 저장하는 것이다.
- 동작 방식
  - 트랜잭션 내 기록: 애플리케이션은 `하나의 트랜잭선` 안에서 ① 비즈니스 데이터(주문 정보)를 해당 테이블에 저장하고, ② 발행할 이벤트('주문 생성' 이벤트)를 `Outbox` 테이블에 함께 기록한다
  - 비동기 전송: 별도의 프로세스인 `메시지 릴레이(Message Relay)`가 주기적으로 Outbox 테이블을 `확인(Polling)`한다.
  - 이벤트 발행 및 상태 변경: 릴레이는 아직 전송되지 않은 이벤트를 가져와 Kafka 같은 메시지 브로커로 전송한다. 전송이 성공하면 해당 이벤트는 Outbox 테이블에서 삭제되거나 '전송 완료' 상태로 변경된다.
- 장점
  - 이벤트 유실 방지: DB 트랜잭션이 성공하면 이벤트가 Outbox 테이블에 반드시 저장되므로, 메시지 브로커 장애와 무관하게 이벤트가 유실되지 않는다
  - 시스템 분리: 서비스 로직과 메시지 발행 로직이 분리되어 있어, 외부 메시지 브로커 장애가 서비스의 핵심 기능에 직접적인 영향을 주지 않는다
- 단점
  - 추가 관리 포인트: Outbox 테이블을 직접 생성하고 관리해야 한다
  - 릴레이 구현 필요: Outbox 테이블의 이벤트를 읽어 메시지 브로커로 전달하는 '메시지 릴레이'를 별도로 구현하고 운영해야 한다
- 결론
  - Two-Phase Commit의 단점을 극복하면서 데이터 일관성을 효과적으로 보장할 수 있어, 마이크로서비스 환경에서 가장 널리 사용되는 현실적인 해결책 중 하나이다.

### Transaction Log Tailing (트랜잭션 로그 테일링)
- 개념
  - 데이터베이스가 모든 변경 사항을 기록하는 내부 `트랜잭션 로그(MySQL의 binlog, PostgreSQL의 WAL)`를 직접 `감시(Tailing)`하여 변경 사항을 이벤트로 발행하는 방식이다. `CDC(Change Data Capture)` 기술이 이 패턴을 구현하는 핵심이다
- 동작 방식
  - DB 변경: 클라이언트 요청에 따라 애플리케이션은 데이터베이스의 테이블 상태만 변경한다
  - 로그 기록: 데이터베이스는 이 변경 사항을 내부 트랜잭션 로그에 기록한다
  - 로그 감지 및 전송: `Transaction Log Miner` (Debezium과 같은 CDC 도구)가 이 로그를 실시간으로 읽어 변경 데이터를 포착한다
  - 이벤트 발행: CDC 도구는 포착한 변경 데이터를 이벤트 메시지 형태로 변환하여 Kafka 같은 메시지 브로커로 전송한다
- 장점
  - 애플리케이션 코드 단순화: 애플리케이션은 데이터베이스 작업에만 집중하면 되므로, Outbox 테이블 관리나 이벤트 발행 코드가 필요 없다. Data Table 변경만 추적하면 Outbox 테이블이 필요 없을 수 있다
  - 신뢰성 높은 데이터 캡처: 데이터베이스가 보장하는 트랜잭션 로그를 기반으올 하므로 데이터 변경을 누락 없이 안정적으로 감지할 수 있다
- 단점
  - CDC 도구 도입/운영 비용: Debezium과 같은 CDC 도구를 별도로 설치하고 운영해아 하므로, 추가적인 학습 및 인프라 관리 비용이 발생한다
  - 데이터베이스 의존성: 데이터베이스의 로그 형식에 의존적이므로, 데이터베이스 종류나 버전에 따라 구현 방식이 달라질 수 있다
- 결론
  - 애플리케이션 코드 변경을 최소화하면서 데이터 변경을 안정적으로 이벤트화할 수 있는 강력한 방법이지만, CDC 대한 이해와 운영 역략이 필요하다.


## Transaction Messaging – Outbox 패턴 채택
- Two Phase Commit: 지연, 성능 저하, 오류 처리 복잡성, Kafka·MySQL 통합 어려움으로 부적합하다고 판단
- Outbox Table
  - Data Table 변경만 추적하는 Log Tailing 보다 이벤트 정보를 명확히 정의 가능하다
  - 테이블 관리 비용이 늘지만 구조적 유연성을 확보할 수 있다
  - MySQL 단일 트랜잭션으로 데이터 변경과 Outbox 기록을 함께 처리 가능하다
- Transaction Log Tailing: CDC 학습·운영 부담이 커서 사용하지 않는다
- 최종 결정: Article, Comment, Like, View 서비스에 Transactional Outbox를 적용하고, Outboxx → Kafka 전송은 Spring Boot에서 직접 개발·운영

## Transactional Outbox 설계 요약
- 샤딩 환경에서 `비즈니스 로직 변경`과 `Outbox 이벤트 기록을 동일 샤드에서 단일 트랜잭션`으로 처리한다고 가정한다
- 이벤트 처리 흐름
  - 게시글/댓글/좋아요/조회수 서비스 API 호출 시, 비즈니스 로직을 수행 + Outbox 이벤트 기록 → 트랜잭션으로 함께 처리한다
  - `Message Relay`가 Outbox의 미전송 이벤트를 Kafka로 전송한다
    - 기본: 10초 간격  polling
    - 최적화: 트랜잭선 commit 후 즉시 Relay에 전달 → 실패 시에만 polling 한다
    - polling은 `생성 후 10초 이상 지난 이벤트`만 대상으로 처리한다
  - 전송 완료 이벤트는 Outbox Table에서 삭제(이벤트 전송 용도로만 사용하기 때문에 단순하게 구조를 유지)한다
- 중복 처리 방지
  - 다수 서버와 샤드 환경에서 polling 시, Coordinator가 샤드를 애플리케이션별로 분산 할당한다
  - Coordinator는 Redis Sorted Set에 3초 간격 ping으로 실행 노드 상태를 기록하며, 9초 이상 ping 없으면 노드 종료로 판단한다
- 확장성
  - Message Relay를 모듈화하여 각 서비스에 쉽게 적용 가능하도록 한다
  - Coordinator가 샤브 범위 기반으로 polling을 분담한다(4샤드 → 2대 서버라면 01, 23 분배) 