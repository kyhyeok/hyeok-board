# CQRS (Command Query Responsibility Segregation) 패턴 요약 및 적용 전략
- CQRS는 `명령(Command)과 조회(Query)의 책일음 분리한다`는 단순하지만 강력한 원칙에 기반한 아키텍처 패턴이다.
이를 통해 시스템의 각 부분을 독립적으로 최적화하고 확장할 수 있다.

## CQRS의 핵심 개념
- 시스템의 데이터 관련 작업을 두 가지 역할로 명확히 구분한다.

### Command (명령)
- `역할`: 데이터의 상태를 변경하는 모든 작업 (생성, 수정, 삭제 - Insert, Update, Delete)
- `특징`: 데이터 일관성 유지가 중요하며, 복잡한 비즈니스 로직 및 유효성 검사를 포함할 수 있다.
- 시스템의 예: 게시글/댓글/좋아요 생성 및 수정 서비스

### Query (조회)
- `역할`: 데이터를 읽는 모든 작업 (Select)
- `특징`: 시스템의 상태를 변경하지 않으며, 오직 데이터를 조회하는 책임만 가져간다. 빠르고 효율적인 조회를 위해 최적화된다.
- 시스템의 예: 신규로 구축할 게시글 조회 전용 서비스

- 이러한 책임 분리는 클래스나 패키지 같은 작은 단위부터, 마이크로서비스나 데이터 저장소 같은 큰 단위까지 다양한 수준에서 적용될 수 있다.

## 프로젝트에 CQRS 적용하기: 게시글 조회 최적화 전략

### 1단계: Command와 Query 서비스 분리
- `Command 서비스`: 기존의 게시글/댓글/좋아요 서비스가 이 역할을 그대로 수행한다. 데이터의 생성 및 변경 책임을 가진다.
- `Query 서비스`: 게시글 조회를 전담하는 `게시글 조회 서비스`를 신규로 구착한다. 이는 마이크로서비스 레벨에서 책임을 분리하는 것이다.

### 2단계: 데이터 동기화 - 이벤트 기반 아키텍처 활용
- 문제점: Query 서비스가 실시간으로 Command 서비스에 API를 호출해 데이터를 가져오면, 부하와 장애가 전파되고 시스템 간 결합도가 높아지는 문제가 발생한다.
- 해결책: 이미 구축된 `Kafka(메시지 브로커)`를 활용한다.
  - `Command 서비스(Producer)`에서 `데이터 변경 이벤트(게시글 생성, 좋아요 추가 등)`가 발생하면 Kafka로 이벤트를 발행한다.
  - `게시글 조회 서비스(Consumer)`는 이 이벤트를 구독하여 자신의 데이터베이스를 최산 상태로 유지한다. 이를 통해 두 서비스는 비동기적으로 통신하며 느슨하게 결합된다.

### 3단계: 조회 최적화를 위한 Query 모델 설계 (비정규화)
- 문제: 조회수 읽기(Query) 작업이 발생할 때마다 쓰기(Command)가 일어나는 독특한 특성을 가진다.
만약 조회수가 오를 때마다 전체 Query 모델을 업데이트한다면, 읽기 트래픽이 쓰기 트래픽을 유발하여 오히려 비효율적이다
- 최적화 전략
  - `조회수 데이터 분리`: 조회수는 기존의 조회수 서비스가 Redis를 통해 이미 빠르게 처리하고 있으므로, 그 구조를 그대로 활용한다.
  - `데이터 조합`: `게시글 조회 서비스`는 기본 정보(게시글+댓글수_좋아요수)는 자신의 Redis에서 가져오고, `조회수`는 `조회수 서비스`에 직접 요청하여 가져온 후 조합한다.
  - `추가 캐싱`: `게시글 조회 서비스`에서 조회수 서비스로의 잦은 요청을 줄이기 위해, 가져온 조회수 데이터를 자체적으로 짧은 시간 동안 캐시(예: 수십 초)하여 부하를 더욱 줄일 수 있다.

`결론적으로` CQRS 패턴을 적용함으로써 `조회 성능을 극대화`하고, Command와 Query 시스템을 `독립적으로 확장`할 수 있게 된다.
또한, 각 책임에 맞게 `최적의 기술(데이터 모델, 데이터베이스)을 유연하게 선택`할 수 있어 시스템 전체의 효율성과 유지보수성을 크게 향상시킬 수 있다.