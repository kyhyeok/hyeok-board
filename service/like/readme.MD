## 데이터베이스 생성
- create database article_like;

## 좋아요 테이블 (article_like)
| 컬럼명             | 데이터 타입     | 설명 / 제약조건       |
|-----------------|---------------|-------------------|
| article_like_id | BIGINT        | Primary Key       |
| article_id      | BIGINT        | 게시판 ID(Shard Key) |
| user_id         | BIGINT        | 작성자 ID            |
| created_at      | DATETIME      | 생성 시간             |

## 좋아요 수 테이블 (article_like_count)
| 컬럼명        | 데이터 타입     | 설명 / 제약조건              |
|------------|---------------|------------------------|
| article_id | BIGINT        | Primary Key(Shard Key) |
| like_count | BIGINT        | 좋아요 수                  |
| version    | BIGINT      | 낙관적 락 버전 컬럼            |

- 각 사용자는 각 게시글에 1회 좋아요를 할 수 있다
  - 취소도 가능하다
- 좋아요는 가 게시글마다 1회만 수행 된다
  - 1개의 고유한 데이터만 관리되어야 한다


## Primary Key
- 오름차순 유니크 숫자를 만들기 위해 SnowFlask를 활용

## 유니크 인덱스 사용
- 게시글 ID + 사용자 ID로 유니크 인덱스를 만들면 된다

## 좋아요 수
- 쓰기 트래픽이 비교적 크디 않고 일관성이 중요하다.
  - 좋아요 테이블의 데이터 생성/삭제와 좋아요 수 갱신을 하나의 트랜잭션으로 묶는 방법이 있다. (Record Lock 발생할 수 있음)
  - 락을 오래 점유하면 발생하는 문제는 치명적이고 다양하다
  - 분산된 시스템에서 분산 트랜잭션이 필요한데 분산 트랜잭션은 상대적으로 느리고 복잡할 수 있다
- 좋아요 서비스의 데이터베이스에 좋아요 수를 관리

## 동시성 문제
- 높은 쓰기 트래픽으로 인해서 동시성 문제가 발생할 수 있고 그로인해 데이터 일관성이 꺠질 수 있다

## 해결방법
### _비관적 락_
- 데이터에 접근할 때 `항상 충돌이 발생할 수 있다고 가정`하고, 데이터를 보호하기 위해 `접근 시점에 즉시 락을 걸어` 다른 트랜잭션의 접근을 차단하는 방식
- `다른 트랜잭션은 락이 해제될 때까지 대기`해야 함
- 주로 `동시성 문제가 빈번하게 발생하는 환경`에서 사용
- 락을 오랫동안 점유하면 `성능 저하` 또는 `데드락(교착상태)` 등 장애가 발생할 수 있음

### _낙관적 락_
- `데이터 충돌 가능성이 낮다고 가정`하고, 데이터 변경 시에만 충돌 여부를 확인하는 방식
- 데이터 수정 시 `version 컬럼`을 활용해 데이터 변경 여부를 추적
- 트랜잭션이 데이터를 읽을 때 version 값을 함께 조회
- 데이터를 수정할 때, `WHERE 조건에 조회한 version을 포함`시켜 update
- update 성공 시 충돌 없음, update 실패 시 충돌 발생(다른 트랜잭션에서 이미 데이터가 변경된 경우)
- 충돌 발생 시 rollback, 재시도 등 `후처리 작업이 필요`
- 충돌 감지와 후처리는 `DB가 아닌 애플리케이션에서 구현`해야 함

### _비동기 순차 처리_
- `모든 요청을 실시간으로 처리할 필요가 없다는 관점에서, 요청을 대기열(큐)에 저장한 뒤 비동기로 순차 처리`
- 각 게시글(또는 단위 데이터)별로 1개의 스레드에서 순차 처리하면 동시성 문제가 해소됨
- `락으로 인한 지연이나 실패가 최소화`되지만, 즉시 응답하지 않아 사용자 입장에서는 지연이 발생할 수 있음
- 비동기 처리 시스템 구축, 일관성 보장, 실패·지연에 대한 클라이언트 처리 등 `추가 비용 및 설계가 필요`
- 큐에서 중복/누락 없이 `1회만 실행`되도록 보장하는 시스템 구현이 중요


## 좋아요 수 설계
- 좋아요 데이터 3,000개

### 비관적 락 - 방법 1
- update
  - update like_count = like_count + 1
  - count: 3001, 소요 시간 5,154ms

### 비관적 락 - 방법 2
- select for update - update
  - select for update 
  - update like_count = like_count + 1
  - count: 3001, 소요 시간 6,174ms

### 낙관적 락
- version
  - count: 349, 소요 시간 6,118ms
  - 낙관적 락의 count는 동시요청이 들어올 떄 충돌 감지 이후 롤백으로 인해 동시요청이 많으면 실패하는 케이스가 많아서 count가 적게 나옴